
Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Кафедра програмної інженерії

Звіт
З лабораторної роботи №2
З дисципліни «Архітектура програмного забезпечення»
на тему: «РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ СИСТЕМИ »

Виконавець:		
ст. гр. ПЗПІ-22-7						                    Тригуб І. О. 

Перевірив:		
ст. викладач кафедри ПІ				                    Сокорчук І. П. 
	


                                                                                                       









Харків 2025
 
1 ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін та виправлень
1	10.05.2025	0.1	Створено розділ «Завдання»
2	12.05.2025	0.1	Створено розділ «Опис виконаної роботи»
3	15.05.2025	0.1	Наповнено додатки А та Б
4	18.05.2025	0.1	Підбито висновки роботи
5	20.05.2025	0.1	Заповнено додаток В з програмним кодом

2 ЗАВДАННЯ

Метою лабораторної роботи є розробка бази даних для серверної частини програмної системи HealthCare та прикладного програмного інтерфейсу (API) для взаємодії з клієнтами. Завдання включають:
1.	Розробка будови програмної системи.
2.	Створення UML діаграми прецедентів для серверної частини.
3.	Створення ER діаграми даних.
4.	Розробка бази даних програмної системи.
5.	Створення діаграми структури бази даних.
6.	Розробка функцій для роботи з базою даних.
7.	Розробка REST API для взаємодії серверної частини з клієнтами.
8.	Створення специфікації API.
9.	Створення програмної реалізації API та функцій роботи з базою даних.
10.	Перевірка роботи створеного програмного коду.
11.	Завантаження коду до GitHub-репозиторію.
12.	Створення відеозапису з демонстрацією тестування функціональності серверної частини.
13.	Завантаження звіту у форматі PDF на платформу dl.nure.ua та у текстовому форматі до GitHub.
3 ОПИС ВИКОНАНОЇ РОБОТИ

У межах лабораторної роботи було реалізовано серверну частину програмної системи AutoCare, призначеної для моніторингу стану автомобіля за допомогою IoT-сенсорів, збору та обробки даних, а також інформування користувачів про необхідність технічного обслуговування. Система включає сервер, IoT-пристрої, веб-клієнт та мобільний додаток.
Серверна частина розроблена на основі платформи Node.js з використанням фреймворку Express.js. Для зберігання даних використовується NoSQL база даних MongoDB, а взаємодія з нею реалізована через ORM-бібліотеку Mongoose. Обмін даними з IoT-пристроями здійснюється за допомогою протоколу MQTT. ІoT-пристрої збирають інформацію про технічний стан автомобіля, зокрема тиск у шинах, температуру двигуна, рівень заряду акумулятора, рівень палива та знос гальмівних колодок.
Клієнтська частина системи складається з веб-застосунку на React з Tailwind CSS для адміністрування та відображення даних, а також мобільного застосунку для Android, реалізованого на Kotlin, який забезпечує перегляд даних у реальному часі та надсилання push-сповіщень.
Було розроблено UML діаграму прецедентів, яка описує основні сценарії використання системи. Серед основних акторів виділяються користувач (User), що має змогу реєструватися, авторизуватися, додавати автомобілі, переглядати дані сенсорів, отримувати сповіщення, та адміністратор (Admin), який має додаткові функції — керування користувачами та резервне копіювання бази даних.
ER-діаграма системи моделює сутності: користувачі, автомобілі, сенсори, технічне обслуговування, сповіщення. Кожна з цих сутностей реалізована у вигляді окремої колекції в MongoDB зі своєю структурою та взаємозв’язками. Для кожної сутності реалізовано CRUD-функціональність. Наприклад, є можливість зареєструвати користувача, додати автомобіль, створити або переглянути записи про технічне обслуговування, а також працювати з системою сповіщень.
Розроблено REST API для взаємодії з клієнтами. Основні маршрути:
•	Users: реєстрація, авторизація, профіль користувача.
•	Devices: прив’язка IoT-пристроїв, перегляд статусу.
•	HealthData: запис та отримання показників.
•	Reminders: нагадування про медичні огляди.
•	Notifications: push-сповіщення користувачам.
API реалізовано з використанням контролерів, маршрутів та middleware для автентифікації за допомогою JWT і контролю доступу за ролями.
Функціональність API протестовано через Postman:
•	Створення користувача;
•	Авторизація;
•	Передача та отримання даних із сенсорів;
•	Генерація рекомендацій;
•	Надсилання сповіщень.
Програмна реалізація API включає контролери, маршрути та middleware для автентифікації (JWT) і авторизації користувачів з урахуванням ролей.
Для перевірки працездатності системи було виконано тестування API-запитів за допомогою Postman. Зокрема, перевірено: реєстрацію та авторизацію користувачів, додавання та видалення автомобілів, обробку даних сенсорів, роботу сповіщень, функції адміністратора. Результати тестування представлені у відеозаписі на YouTube, посилання на який наведено в кінці звіту. Усі матеріали — код, діаграми та опис — завантажено до GitHub-репозиторію, а також експортовано у PDF та текстовий файл у форматі UTF-8.

ВИСНОВКИ

У результаті виконання лабораторної роботи №2 було розроблено базу даних для серверної частини системи AutoCare з використанням MongoDB та бібліотеки Mongoose. Створено UML діаграму прецедентів, ER діаграму та діаграму структури бази даних. Реалізовано REST API для взаємодії з клієнтами, включаючи маршрути для керування користувачами, автомобілями, технічним обслуговуванням та сповіщеннями. Функції роботи з базою даних забезпечують виконання CRUD-операцій. API протестовано на відповідність функціональності, описаній у розділі 3.1 Vision & Scope. Код завантажено до GitHub-репозиторію, а звіт підготовлено для експорту у форматі PDF та текстовий файл з кодуванням UTF-8.
 
ДОДАТОК А
Відеозапис

Відеозапис презентації результатів лабораторної роботи: https://youtu.be/suwHt6cHCgM

Хронологічний опис відеозапису:
00:00 - Вступ 
00:10 - Реєстрація нового користувача 
00:38 - Авторизація користувача 
00:50 - Активація користувача 
00:52 - Перегляд інформації щодо користувача 
01:06 - Перегляд інформації щодо всіх користувачів 
01:30 - Вихід із системи
 
ДОДАТОК Б

Графічні матеріали

Рисунок Б.1 — ER-діаграма даних


 
Рисунок Б.2 — UML-діаграма прецедентів

UML діаграми активності



Рисунок Б.3 – UML діаграма створення сповіщення


Діаграма на рис. Б.3 активності демонструє логіку перевірки та створення нового сповіщення в системі.


Рисунок Б.4 – UML діаграма видалення користувача
 
Діаграма на рис. Б.4 описує, як система опрацьовує запит на видалення користувача.



Рисунок Б.5 – UML діаграма отримання сповіщень

Діаграма на рис. Б.5 демонструє процес отримання всіх сповіщень для адміністратора.



Рисунок Б.6 – UML діаграма додавання даних здоров’я користувача
 
Діаграма на рис. Б.6 показує, як система додає інформацію про здоров’я користувача у базу даних після валідації вхідних даних.



Рисунок Б.7 – UML діаграма видалення сповіщення


Діаграма на рис. Б.7 ілюструє, як система обробляє запит на видалення сповіщення.



ДОДАТОК В
Програмний код

В.1 Логіка взаємодії серверної частини з базою даних
GitHub репозиторій:

1  const mongoose = require('mongoose');
2  const Vehicle = require('../models/vehicle');
3  
4  exports.addVehicle = async (req, res) => {
5      const { user_id, make, model, year, vin_number } = req.body;
6      try {
7          if (!mongoose.Types.ObjectId.isValid(user_id)) {
8              return res.status(400).json({ message: 'Invalid user_id format' });
9          }
10         const vehicle = new Vehicle({
11             user_id: new mongoose.Types.ObjectId(user_id),
12             make,
13             model,
14             year,
15             vin_number,
16         });
17         await vehicle.save();
18         res.status(201).json({ message: 'Vehicle added successfully' });
19     } catch (error) {
20         res.status(400).json({ message: 'Error adding vehicle', error: error.message });
21     }
22 };
23  
24 exports.deleteVehicle = async (req, res) => {
25     const { vehicle_id } = req.params;
26     try {
27         const vehicle = await Vehicle.findByIdAndDelete(vehicle_id);
28         if (!vehicle) {
29             return res.status(404).json({ message: 'Vehicle not found' });
30         }
31         res.status(200).json({ message: 'Vehicle deleted successfully' });
32     } catch (error) {
33         res.status(500).json({ message: 'Error deleting vehicle', error: error.message });
34     }
35 };
36  
37 exports.getVehicles = async (req, res) => {
38     const { user_id } = req.query;
39     try {
40         const vehicles = await Vehicle.find({ user_id: new mongoose.Types.ObjectId(user_id) });
41         if (!vehicles || vehicles.length === 0) {
42             return res.status(404).json({ message: 'No vehicles found for this user' });
43         }
44         res.status(200).json(vehicles);
45     } catch (error) {
46         res.status(500).json({ message: 'Error retrieving vehicles', error: error.message });
47     }
48 };


В.2 Логіка взаємодії серверної частини з клієнтами
GitHub репозиторій: 

1  const express = require('express');
2  const router = express.Router();
3  const { getAllUsers, registerUser, loginUser, deleteUser } = require('../controllers/userController');
4  const { addVehicle, deleteVehicle, getVehicles } = require('../controllers/vehicleController');
5  const { addMaintenance, getMaintenance } = require('../controllers/maintenanceController');
6  const { createNotification, getNotifications } = require('../controllers/notificationController');
7  
8  // User routes
9  router.get('/users', getAllUsers);
10 router.post('/register', registerUser);
11 router.post('/login', loginUser);
12 router.delete('/users/:user_id', deleteUser);
13  
14 // Vehicle routes
15 router.post('/vehicles', addVehicle);
16 router.delete('/vehicles/:vehicle_id', deleteVehicle);
17 router.get('/vehicles', getVehicles);
18  
19 // Maintenance routes
20 router.post('/maintenance', addMaintenance);
21 router.get('/maintenance/:vehicle_id', getMaintenance);
22  
23 // Notification routes
24 router.post('/notifications', createNotification);
25 router.get('/notifications', getNotifications);
26  
27 module.exports = router;

